

2023-05-08

----
#게임서버프로그래밍교과서 #메모리 #CS 

## 개요
다음 코드를 보자.
```C++
x = 2; // 'data that can be raced'

x += 3; // thread 1
x += 4; // thread 2
// intended result was x = 9
```

기대하는 결과는 `x = 9`였으나, 실제 프로그램을 실행시켜서 나오는 결과는 항상 9가 나오지 않는다.

## 내용
위와 같은 결과가 나오는 이유는 [[컨텍스트 스위치(Context Switch)]]가 작업을 명령어 단위로 바꾸는게 아니라 기계어 단위로 바꾸기 때문이다.

개요에 나온 코드를를 기계어로 컴파일하면 다음과 같다.
(기계어를 우리가 쓰는 high-level 언어로 번역해주는 소프트웨어를 [[컴파일러 (Compiler)]]라고 한다.
이 경우 컴파일러가 쓰는 언어는 'gcc'이다.)
```gcc
t1 = x 
t1 = t1 + 3
x = t1
```

위 기계어 세 줄을 스레드 두개가 실행한다고 해보자.
실행 동안 다음과 같이 컨텍스트 스위치가 발생한다고 해보자.
```gcc
x = 2 

// thread 1
t1 = x       // t1 = 2
t1 = t1 + 3  // t1 = 5
x = t1       // x = 5

// thread 2
t2 = x       // t2 = 5
t2 = t2 + 4  // t2 = 9

x = t2       // x = 9
```

우리가 원하던 결과가 나온다.
하지만 다음과 같이 실행된다면?
```gcc
x = 2 

// thread 1
t1 = x       // t1 = 2
t1 = t1 + 3  // t1 = 5

// thread 2
t2 = x       // t2 = 2
t2 = t2 + 4  // t2 = 6

// thread 1
x = t1       // x = 5
```

이렇게 `t1`이 연산하던 곳부터 `t2`가 연산에 들어가는게 아니라, 원래 주어졌던 `x = 2`의 값을 가져다가 연산을 시작하기에 `x = 5`라는 희한한 결과가 나오는 것이다.

그럼 이것을 [[기기의 CPU 자원을 모두 사용하지 못할 때]]에 나온 코드에 적용하여 이해해 보자.