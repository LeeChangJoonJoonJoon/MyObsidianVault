

2024-08-10

----
#메모리 #최적화 #Cpp #CS 

## 개요
씹어먹는 c++의 코드를 보면, 문자열 길이를 늘리고자 할 때 다음과 같은 로직으로 짠다. 
```cpp
MyString& MyString::insert(int loc, const MyString& str) {
  // 이는 i 의 위치 바로 앞에 문자를 삽입하게 된다. 예를 들어서
  // abc 라는 문자열에 insert(1, "d") 를 하게 된다면 adbc 가 된다.

  // 범위를 벗어나는 입력에 대해서는 삽입을 수행하지 않는다.
  if (loc < 0 || loc > string_length) return *this;

  if (this->string_length + str.string_length > memory_capacity) {
    // 이제 새롭게 동적으로 할당을 해야 한다.

    if (memory_capacity * 2 > string_length + str.string_length)
      memory_capacity *= 2;
    else
      memory_capacity = string_length + str.string_length;

    char* prev_string_content = string_content;
    string_content = new char[memory_capacity];

    // 일단 insert 되는 부분 직전까지의 내용을 복사한다.
    int i;
    for (i = 0; i < loc; i++) {
      string_content[i] = prev_string_content[i];
    }

    // 그리고 새롭에 insert 되는 문자열을 넣는다.
    for (int j = 0; j != str.string_length; j++) {
      string_content[i + j] = str.string_content[j];
    }

    // 이제 다시 원 문자열의 나머지 뒷부분을 복사한다.
    for (; i < string_length; i++) {
      string_content[str.string_length + i] = prev_string_content[i];
    }

    delete[] prev_string_content;

    string_length = string_length + str.string_length;
    return *this;
  }
```

성능의 최적화를 위해, 최초 메모리 할당할 때 문자열을 담기 위해 필요한 양 보다 두배를 할당.
그리고 다음부턴 새로 메모리를 할당할 필요가 있는지 확인 후 필요하면 필요의 두배를, 필요 없으면 추가로 0을 할당.
근데 이게 최선이야?

## 내용
`vector.h`에서는 메모리 할당을 어떻게 할까?
다음 코드를 보자. 
```cpp
vector<bool, _Allocator>::__insert_with_size(const_iterator __position, _ForwardIterator __first, _Sentinel __last,  
                                             difference_type __n_signed) {  
    _LIBCPP_ASSERT_VALID_INPUT_RANGE(__n_signed >= 0, "invalid range specified");  
    const size_type __n = static_cast<size_type>(__n_signed);  
    iterator __r;  
    size_type __c = capacity();  
    if (__n <= __c && size() <= __c - __n)  
    {        const_iterator __old_end = end();  
        __size_ += __n;  
        std::copy_backward(__position, __old_end, end());  
        __r = __const_iterator_cast(__position);  
    }    else  
    {  
        vector __v(get_allocator());  
        __v.reserve(__recommend(__size_ + __n));  
        __v.__size_ = __size_ + __n;  
        __r = std::copy(cbegin(), __position, __v.begin());  
        std::copy_backward(__position, cend(), __v.end());  
        swap(__v);  
    }    std::__copy<_ClassicAlgPolicy>(__first, __last, __r);  
    return __r;  
}
```

