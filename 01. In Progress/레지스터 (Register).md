

2023-05-08

----
#게임서버프로그래밍교과서 #메모리 #CS #Cpp

## 개요
[[기기의 CPU 자원을 모두 사용하지 못할 때]]의 예제 코드가 왜 멀티 스레드 관련 에러를 뱉는지에 대해 공부하던 중, 다음과 같은 설명을 보게 되었다.
> ![[스크린샷 2023-05-13 오후 4.29.56.png]]
> 
> `num`이라는 정보를 보관하는 데 필요한 것은 정수형 4바이트 데이터 공간 하나뿐입니다. 하지만 `Array<int> primes` 정보를 보관하는 데 필요한 데이터는 하나 이상입니다. 우선 `Array<int>`는 배열 객체를 가리키는 포인터 변수와 배열이 크기를 멤버 변수로 가질 것입니다. 배열 객체는 메모리 힙에서 할당되었을 것이고, 메모리 힙은 현재 실행 중인 프로세스의 런타임 라이브러리로 다루어 집니다.
> 출처: ![[게임 서버 프로그래밍 교과서.pdf]]

## 내용
위 예시에서 나온 코드의 메인함수의 첫번째 `for`문은 `ThreadProc`이란 작업을 네개의 스레드에 부여하는 역할을 한다. 
이 `ThreadProc()` 메서드는 백만에 이르기까지의 소수를 구한다.
아마 저 코드를 쓴 의도는, 여러개의 스레드가 `num` 값을 꺼내 와서 그것이 소수인지 판별하고 `num` 값에 1을 더하는 식으로 각각이 일하여서 작업을 효율적으로 분배하도록 한 것이었던 듯 하다.
스레드 1이 이미 1부터 10까지의 소수를 구했고 `num` 변수의 값을 11로 만들어 놓았다면 다른 스레드는 11부터 검사를 작하는 방식으로 말이다!

저자는 여기서 [[데이터 레이스 (Data Race)]] 정도가 아니라 아예 크래쉬(Crash)가 난 상황이라고 지적하면서, 위의 설명이 등장했던 것이다.

다음 C언어 코드를 보자.
```c
#include <stdio.h>

int countFunc()
{
	int count = 0;
	count++;
	return count;
}

void callNumFunc(int param)
{
	printf("함수 호출 횟수는 %d입니다\n", param);
}

void main()
{
	int num = 0;
	for (int i = 0;i < 10;i++)
		num = countFunc();

	callNumFunc(num);
}
```

`count` 변수는 지역변수이기 때문에 `countFunc()`이 호출될 때 Stack에 생성되고 `return count`할 때 레지스터의 임시변수에 값을 전달하고	Stack에서 소멸된다.
